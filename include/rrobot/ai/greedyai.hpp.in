#ifndef GREEDYAI_HPP
#define GREEDYAI_HPP

#include <queue>
#include <rrobot/ai/ai.hpp>
#include <rrobot/state/state_manager.hpp>
#include <vector>

namespace rrobot {

enum PSTATE {
    P_AVAILABLE,
    P_NOT_AVAIL,
};

class GreedyAi {
   public:
    GreedyAi(StateManager& smg) : _smg(smg) { init();}
    ~GreedyAi() {
        _excluded.clear();
        _explored.clear();
    }

    float absDistance(float n1, float n2);
    float sqr(float n);

    /**
     * @fn calcPath
     * @brief find the most viable delta, if one is available.
     * @param path queue.
     * @return returns P_AVAILABLE if a path is available, or P_NOT_AVAIL if a path is not available.
     */
    PSTATE calcPath(msp_delta_xy d);
    
    vector<msp_delta_xy> _explored;
    vector<msp_delta_xy> _excluded;

    bool isExplored(msp_delta_xy x);
    bool isExcluded(msp_delta_xy x);
    bool isValid(float x, float y);

   private:

   void init();
   void teardown();

   bool isExp(msp_delta_xy x, vector<msp_delta_xy> exp);
    // previously explored deltas

    StateManager& _smg;
};
}  // namespace rrobot

#endif  // GREEDYAI_HPP